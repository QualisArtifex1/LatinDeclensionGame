<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Latin Declension Drag & Drop ‚Äî Polished UI</title>
  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <!-- Confetti -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
  <style>
    :root{
      /* Brand */
      --royal: #3b5bdb;         /* primary */
      --royal-600: #2f49af;
      --gold:  #c0a25c;         /* accent */
      --ink:   #0f172a;         /* text */
      --ink-2: #334155;         /* secondary text */
      --bg:    #f6f8fc;         /* page */
      --card:  #ffffff;         /* surfaces */
      --ok:    #16a34a;         /* success */
      --warn:  #f59e0b;         /* warning */
      --bad:   #ef4444;         /* error */
      --muted: #e5e7eb;         /* outlines */

      --radius: 14px;
      --shadow: 0 6px 20px rgba(0,0,0,.08);

      --cell-min: 56px;         /* min cell size */
      --gap: 12px;
    }

    /* Dark mode (automatic) */
    @media (prefers-color-scheme: dark){
      :root{
        --bg:#0b1020; --card:#0f162e; --ink:#e5e7eb; --ink-2:#cbd5e1; --muted:#1f2a44;
        --royal:#6ea8ff; --royal-600:#5d8fe0; --gold:#c9b27a; --shadow: 0 6px 24px rgba(0,0,0,.35);
      }
    }

    /* Manual theme overrides */
    body[data-theme="dark"]{
      --bg:#0b1020; --card:#0f162e; --ink:#e5e7eb; --ink-2:#cbd5e1; --muted:#1f2a44;
      --royal:#6ea8ff; --royal-600:#5d8fe0; --gold:#c9b27a; --shadow: 0 6px 24px rgba(0,0,0,.35);
    }
    body[data-theme="light"]{
      --bg: #f6f8fc; --card:#ffffff; --ink:#0f172a; --ink-2:#334155; --muted:#e5e7eb;
      --royal:#3b5bdb; --royal-600:#2f49af; --gold:#c0a25c; --shadow: 0 6px 20px rgba(0,0,0,.08);
    }

    *,*::before,*::after{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--ink);
      margin:0; display:flex; flex-direction:column; align-items:center;
      transition: background .2s ease, color .2s ease;
    }

    header{ position:sticky; top:0; width:100%; z-index: 10; background: linear-gradient(180deg, rgba(0,0,0,.06), transparent 70%); backdrop-filter: blur(6px); }

    .topbar{ max-width: 1100px; margin: 0 auto; padding: 14px 16px; display:flex; gap:12px; align-items:center; }
    .brand{ display:flex; align-items:baseline; gap:10px; }
    .brand h1{ font-family:'Cinzel', serif; font-weight:600; letter-spacing:.5px; margin:0; font-size: clamp(18px, 2.4vw, 28px); }
    .brand .tag{ font-size:12px; padding:4px 8px; border-radius:999px; background:var(--royal); color:white; }

    .spacer{ flex:1; }

    .controls{ display:flex; gap:8px; align-items:center; }
    button, .btn{ font: inherit; font-weight:600; border:1px solid transparent; color:white; background:var(--royal); padding:10px 14px; border-radius:10px; cursor:pointer; box-shadow: var(--shadow); transition: transform .06s ease, background .2s ease; }
    button:hover{ background: var(--royal-600); }
    button:active{ transform: translateY(1px); }
    .btn-ghost{ background:transparent; color:var(--ink); border-color:var(--muted); box-shadow:none; }
    .btn-ghost:hover{ background: rgba(0,0,0,.05); }

    main{ width:100%; max-width:1100px; padding: 12px 16px 32px; }

    .card{ background:var(--card); border:1px solid var(--muted); border-radius: var(--radius); box-shadow: var(--shadow); }

    #selection{ padding:18px; display:grid; gap:16px; margin-top:8px; }
    #selection h2{ font-family:'Cinzel', serif; margin:0; font-size: clamp(18px,2.2vw,24px); }
    .declensions{ display:flex; flex-wrap:wrap; gap:8px; }
    .pill{ display:inline-flex; align-items:center; gap:8px; padding:10px 12px; border-radius:999px; border:1px solid var(--muted); background:transparent; cursor:pointer; user-select:none; transition: background .2s ease, border-color .2s ease, transform .06s; }
    .pill input{ appearance:none; width:0; height:0; }
    .pill.active{ background: rgba(59,91,219,.1); border-color: var(--royal); }
    .hint{ color: var(--ink-2); font-size: 14px; }

    .footer-actions{ display:flex; gap:10px; justify-content:flex-end; }

    #game.card{ margin-top:14px; padding:14px; display:grid; gap:14px; }

    .hud{ display:flex; flex-wrap:wrap; align-items:center; gap:10px; }
    .stat{ display:flex; align-items:center; gap:8px; padding:8px 10px; border:1px solid var(--muted); border-radius:10px; background: rgba(0,0,0,.03); }
    .stat strong{ font-variant-numeric: tabular-nums; }

    .progress{ position:relative; height:10px; background:#e5e7eb; border-radius:999px; overflow:hidden; }
    .progress>span{ position:absolute; inset:0; width:0%; background: linear-gradient(90deg, var(--royal), var(--gold)); }

    .board-wrap{ display:grid; gap: var(--gap); }
    .board{ overflow:auto; border:1px solid var(--muted); border-radius: var(--radius); }
    #board-scale{ transform-origin: top left; will-change: transform; }

    table{ width:100%; border-collapse: separate; border-spacing:0; table-layout: fixed; font-size: clamp(16px, 2.4vw, 18px); }
    thead th{ position:sticky; top:0; background: linear-gradient(180deg, #f8fafc, #eef2ff); z-index:1; }
    th, td{ border-right:1px solid var(--muted); border-bottom:1px solid var(--muted); padding:12px; min-width: var(--cell-min); height:60px; text-align:center; }
    th:first-child, td:first-child{ position:sticky; left:0; background: var(--card); z-index: 1; }

    .row-head{ font-weight:700; }
    .row-head .bar{ display:inline-block; width:10px; height:10px; border-radius:2px; margin-right:6px; vertical-align:middle; }
    .c-nom { --c:#ef4444; } .c-gen { --c:#16a34a; } .c-dat { --c:#f59e0b; } .c-acc { --c:#3b82f6; } .c-abl { --c:#ec4899; }
    .row-head .bar{ background: var(--c); }

    .dropzone{ background: linear-gradient(180deg, transparent, rgba(0,0,0,.02)); border-radius:8px; transition: background .15s ease, box-shadow .15s ease, transform .06s; }
    .dropzone:empty::after{ content:""; }
    .dropzone.drag-over{ outline:2px dashed var(--royal); outline-offset:-6px; background: rgba(59,91,219,.10); }

    .tray{ display:grid; grid-template-columns: 1fr; gap: var(--gap); align-items:center; }
    @media (min-width: 900px){ .tray{ grid-template-columns: 320px 1fr; } }

    .tile-area{ display:grid; gap:10px; align-items:center; justify-items:center; }
    .tile{ background: var(--card); border:2px solid var(--royal); border-radius: 18px; box-shadow: var(--shadow); width: min(20vw, 200px); height: min(20vw, 200px); max-width: 220px; max-height: 220px; min-width: 100px; min-height: 100px; display:flex; align-items:center; justify-content:center; font-size: clamp(24px, 5vw, 44px); font-weight:700; user-select:none; touch-action:none; cursor: grab; position: relative; transition: transform .06s ease; }
    .tile:active{ cursor: grabbing; transform: scale(.98); }

    .queue{ display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
    .chip{ padding:10px 12px; border:1px dashed var(--muted); border-radius:10px; min-width:46px; text-align:center; opacity:.7; font-size: 1.05em; }

    .actions{ display:flex; flex-wrap:wrap; gap:8px; justify-content:flex-end; }
    .btn-ok{ background:var(--ok); }
    .btn-warn{ background:var(--warn); color:#111; }
    .btn-ghost.bad{ color: var(--bad); border-color: color-mix(in oklab, var(--bad) 40%, var(--muted)); }

    .toast{ position: fixed; bottom:14px; left:50%; transform: translateX(-50%); background: var(--ink); color:#fff; padding:10px 14px; border-radius:999px; opacity:0; pointer-events:none; transition: opacity .2s, transform .2s; }
    .toast.show{ opacity:1; transform: translate(-50%, -6px); }

    dialog{ border:none; padding:0; width:min(560px, 92vw); border-radius: 18px; overflow:hidden; background:var(--card); box-shadow: var(--shadow); }
    dialog::backdrop{ background: rgba(0,0,0,.35); backdrop-filter: blur(2px); }
    .modal-head{ padding:16px; border-bottom:1px solid var(--muted); display:flex; align-items:center; gap:10px; }
    .modal-body{ padding:16px; display:grid; gap:12px; }

    :focus-visible{ outline: 3px solid var(--royal); outline-offset: 2px; border-radius: 6px; }
  </style>
</head>
<body>
  <header>
    <div class="topbar">
      <div class="brand">
        <h1>Latin Declension Practice</h1>
        <span class="tag">v2</span>
      </div>
      <div class="spacer"></div>
      <div class="controls">
        <button class="btn-ghost" id="toggle-theme" aria-label="Toggle color theme">Theme</button>
        <button class="btn-ghost" id="open-help" aria-haspopup="dialog">Help</button>
        <button id="reset-all" class="btn-ghost bad" title="Clear board & restart">Reset</button>
      </div>
    </div>
  </header>

  <main>
    <section id="selection" class="card" aria-labelledby="sel-h2">
      <h2 id="sel-h2">Choose Declensions</h2>
      <div class="declensions" id="declension-pills" role="group" aria-label="Declension choices"></div>
      <div class="hint">Tip: you can mix sets (e.g., 1st + 3rd) for spaced practice.</div>
      <div class="footer-actions">
        <button id="btn-start">Start Practice</button>
      </div>
    </section>

    <section id="game" class="card" hidden>
      <div class="hud">
        <div class="stat" aria-live="polite">‚è±Ô∏è <strong id="time">0:00</strong></div>
        <div class="stat">üí° Hints: <strong id="hints">0</strong></div>
        <div class="stat">üéØ Remaining: <strong id="remain">‚Äî</strong></div>
        <div class="stat" style="flex:1 1 220px; min-width:220px">
          <div class="progress" aria-label="Progress"><span id="progress"></span></div>
        </div>
        <div class="spacer"></div>
        <div class="actions">
          <button id="btn-hint" class="btn-warn" title="Fill one correct cell">Hint</button>
          <button id="btn-check" class="btn-ok">Check</button>
          <button id="btn-restart" class="btn-ghost">Restart</button>
        </div>
      </div>

      <div class="tray">
        <div class="tile-area">
          <div id="tile" class="tile" role="button" aria-label="Current ending" tabindex="0"></div>
          <div class="queue" aria-live="polite" aria-atomic="true">
            <div class="chip" id="q1">‚Äî</div>
            <div class="chip" id="q2">‚Äî</div>
            <div class="chip" id="q3">‚Äî</div>
          </div>
          <div class="hint" id="placement-hint">Drag the large tile, or tap a cell to place it.</div>
        </div>

        <div class="board-wrap">
          <div class="board" id="board" role="region" aria-label="Declension table">
            <div id="board-scale">
              <table>
                <thead>
                  <tr id="thead-row"><th>Case</th></tr>
                </thead>
                <tbody id="tbody"></tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <dialog id="help-modal" aria-labelledby="help-title">
    <div class="modal-head"><strong id="help-title">How it works</strong></div>
    <div class="modal-body">
      <ol>
        <li>Pick your declensions, then press <em>Start Practice</em>.</li>
        <li>Drag the big tile onto the correct cell, or tap a cell to place it.</li>
        <li>Press <em>Check</em> to clear any wrong cells and keep going.</li>
        <li>Use <em>Hint</em> if you get stuck ‚Äî it fills one correct cell.</li>
      </ol>
      <p>Keyboard: focus the table cells with <kbd>Tab</kbd>, press <kbd>Enter</kbd> to drop the current tile.</p>
      <div style="text-align:right; padding-top:8px">
        <button class="btn-ghost" id="close-help">Close</button>
      </div>
    </div>
  </dialog>

  <dialog id="finish-modal" aria-labelledby="finish-title">
    <div class="modal-head"><strong id="finish-title">Well done! üéâ</strong></div>
    <div class="modal-body">
      <p><strong>Total time:</strong> <span id="final-time"></span></p>
      <p><strong>Best time for this mix:</strong> <span id="best-time">‚Äî</span></p>
      <div style="display:flex; gap:8px; justify-content:flex-end; padding-top:6px">
        <button id="play-again" class="btn-ok">Play again</button>
        <button id="close-finish" class="btn-ghost">Close</button>
      </div>
    </div>
  </dialog>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>

  <script>
  (function(){
    // ===== Data =====
    const DECL_LABELS = ["1","2","2n","3","3n","4","4n","5"]; // columns
    const CANON_ORDER = [0,1,2,3,4,5,6,7];
    const CASE_LABELS = ['Nominative','Genitive','Dative','Accusative','Ablative','Nominative-P','Genitive-P','Dative-P','Accusative-P','Ablative-P'];
    const CASE_CLASS  = ['c-nom','c-gen','c-dat','c-acc','c-abl','c-nom','c-gen','c-dat','c-acc','c-abl'];

    // Matrix of endings [row][decl]
    const CORRECT = [
      ["a","us/r","um","*","*","us","u","es"],
      ["ae","i","i","is","is","us","us","ei"],
      ["ae","o","o","i","i","ui","u","ei"],
      ["am","um","um","em","*","um","u","em"],
      ["a","o","o","e","e","u","u","e"],
      ["ae","i","a","es","a","us","ua","es"],
      ["arum","orum","orum","um","um","uum","uum","erum"],
      ["is","is","is","ibus","ibus","ibus","ibus","ebus"],
      ["as","os","a","es","a","us","ua","es"],
      ["is","is","is","ibus","ibus","ibus","ibus","ebus"]
    ];

    // ===== State =====
    let selected = new Set([0,1,3]); // default
    let answers = [];         // filtered by selected (canonical order)
    let pool = [];            // initial pool
    let queue = [];           // current queue
    let correctCount = 0;     // number of correct cells (updated on Check)

    let timer = 0; let timerId = null; let running = false;
    let hintsUsed = 0;        // per-round
    const HINT_PENALTY_SEC = 10; // per hint
    const HINT_COOLDOWN_SEC = 10; // cooldown between hints

    // ===== Elements =====
    const selCard = document.getElementById('selection');
    const pillsWrap = document.getElementById('declension-pills');
    const btnStart = document.getElementById('btn-start');

    const gameCard = document.getElementById('game');
    const timeEl = document.getElementById('time');
    const remainEl = document.getElementById('remain');
    const progressBar = document.getElementById('progress');

    const hintsEl = document.getElementById('hints');

    const tileEl = document.getElementById('tile');
    const q1 = document.getElementById('q1');
    const q2 = document.getElementById('q2');
    const q3 = document.getElementById('q3');

    const theadRow = document.getElementById('thead-row');
    const tbody = document.getElementById('tbody');

    const btnCheck = document.getElementById('btn-check');
    const btnRestart = document.getElementById('btn-restart');
    const btnHint = document.getElementById('btn-hint');
    const btnResetAll = document.getElementById('reset-all');

    const helpModal = document.getElementById('help-modal');
    const openHelp = document.getElementById('open-help');
    const closeHelp = document.getElementById('close-help');

    const finishModal = document.getElementById('finish-modal');
    const finalTime = document.getElementById('final-time');
    const bestTime = document.getElementById('best-time');
    const playAgain = document.getElementById('play-again');
    const closeFinish = document.getElementById('close-finish');

    const toast = document.getElementById('toast');

    const toggleTheme = document.getElementById('toggle-theme');

    const board = document.getElementById('board');
    const boardScale = document.getElementById('board-scale');

    // ===== Utils =====
    const fmtTime = (secs)=>{ const m = Math.floor(secs/60), s = secs%60; return `${m}:${s.toString().padStart(2,'0')}`; };
    const shuffle = (arr)=>{ const a = arr.slice(); for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; };
    const orderedSelected = ()=> CANON_ORDER.filter(i=> selected.has(i));
    const keyForMix = ()=> `mix:${orderedSelected().join('-')}`;
    const effectiveTime = ()=> timer + hintsUsed * HINT_PENALTY_SEC;

    function showToast(msg){ toast.textContent = msg; toast.classList.add('show'); setTimeout(()=> toast.classList.remove('show'), 1300); }

    // ===== Timer =====
    function runTimer(on){
      if(on){
        if(running){ clearInterval(timerId); }
        running = true; timer = 0; timeEl.textContent = fmtTime(0);
        timerId = setInterval(()=>{ timer++; timeEl.textContent = fmtTime(effectiveTime()); }, 1000);
      } else { running = false; clearInterval(timerId); }
    }

    // Theme toggle: cycle Auto ‚Üí Dark ‚Üí Light ‚Üí Auto
    toggleTheme.addEventListener('click', ()=>{
      const cur = document.body.dataset.theme || 'auto';
      let next; if(cur==='auto') next='dark'; else if(cur==='dark') next='light'; else next='';
      document.body.dataset.theme = next; showToast(`Theme: ${next||'auto'}`);
    });

    // ===== Selection Pills =====
    function renderPills(){
      pillsWrap.innerHTML = '';
      DECL_LABELS.forEach((lab, idx)=>{
        const pill = document.createElement('button');
        pill.type='button'; pill.className='pill' + (selected.has(idx)?' active':'');
        pill.setAttribute('aria-pressed', selected.has(idx));
        pill.innerHTML = `<input type="checkbox" ${selected.has(idx)?'checked':''} aria-hidden="true"><span>${lab}</span>`;
        pill.addEventListener('click', ()=>{
          if(selected.has(idx)) selected.delete(idx); else selected.add(idx);
          if(selected.size===0){ selected.add(idx); showToast('Select at least one set'); }
          renderPills();
        });
        pillsWrap.appendChild(pill);
      });
    }

    // ===== Board Build =====
    function buildBoard(){
      const ord = orderedSelected();
      answers = CORRECT.map(row => ord.map(c=> row[c]));
      pool = answers.flat();
      correctCount = 0; hintsUsed = 0; updateHintHUD();

      // header (canonical order)
      theadRow.innerHTML = '<th>Case</th>' + ord.map(c=>`<th>${DECL_LABELS[c]}</th>`).join('');

      // body
      tbody.innerHTML = '';
      answers.forEach((row, r)=>{
        const tr = document.createElement('tr');
        const th = document.createElement('th'); th.className='row-head ' + CASE_CLASS[r];
        th.innerHTML = `<span class="bar"></span>${CASE_LABELS[r]}`; tr.appendChild(th);
        row.forEach((_, c)=>{
          const td = document.createElement('td'); td.className='dropzone'; td.tabIndex = 0; td.dataset.r=r; td.dataset.c=c; td.setAttribute('aria-label', `${CASE_LABELS[r]} column ${DECL_LABELS[ord[c]]}`);
          tbody.appendChild(tr); tr.appendChild(td);
        });
      });

      // listeners
      tbody.querySelectorAll('.dropzone').forEach(td =>{
        td.addEventListener('dragover', e=> e.preventDefault());
        td.addEventListener('pointerenter', ()=> td.classList.add('drag-over'));
        td.addEventListener('pointerleave', ()=> td.classList.remove('drag-over'));
        td.addEventListener('click', ()=> placeInCell(td));
        td.addEventListener('keydown', (e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); placeInCell(td); }});
      });

      requestAnimationFrame(fitBoardToScreen);
      updateHUD();
    }

    // ===== Game Flow =====
    function startGame(){
      queue = shuffle(pool); updateQueue(); runTimer(true); requestAnimationFrame(fitBoardToScreen); updateHUD();
      // reset hint cooldown
      enableHint(true);
    }

    function updateHUD(){
      const total = answers.flat().length;
      remainEl.textContent = queue.length;
      const pct = Math.round(100 * (correctCount / total));
      progressBar.style.width = pct + '%';
      timeEl.textContent = fmtTime(effectiveTime());
    }

    function updateHintHUD(){ hintsEl.textContent = `${hintsUsed}`; }

    function updateQueue(){
      if(queue.length===0){ tileEl.textContent=''; q1.textContent=q2.textContent=q3.textContent='‚Äî'; return; }
      const [current, ...rest] = queue; tileEl.textContent = current; q1.textContent = rest[0] ?? '‚Äî'; q2.textContent = rest[1] ?? '‚Äî'; q3.textContent = rest[2] ?? '‚Äî';
    }

    function nextTile(){ queue.shift(); updateQueue(); updateHUD(); }

    function placeInCell(td){
      const val = tileEl.textContent?.trim(); if(!val) return;
      const prev = td.textContent.trim(); if(prev){ queue.push(prev); }
      td.textContent = val; td.style.background=''; td.style.boxShadow='';
      nextTile();
    }

    // ===== Check answers =====
    function checkAnswers(){
      const tds = [...tbody.querySelectorAll('.dropzone')];
      const wrongVals = []; correctCount = 0;
      tds.forEach(td=>{
        const txt = td.textContent.trim(); const r = +td.dataset.r, c = +td.dataset.c; const correct = answers[r][c].toLowerCase();
        if(!txt){ td.style.background=''; td.style.boxShadow=''; return; }
        if(txt.toLowerCase() === correct){
          correctCount++; td.style.background='rgba(22,163,74,.10)'; td.style.boxShadow='inset 0 0 0 2px rgba(22,163,74,.4)';
        } else { td.textContent=''; td.style.background=''; td.style.boxShadow=''; wrongVals.push(txt); }
      });
      if(wrongVals.length){ queue = shuffle(queue.concat(wrongVals)); updateQueue(); showToast(`${wrongVals.length} corrected`); }

      const total = answers.flat().length;
      if(correctCount === total){
        runTimer(false);
        const usedAsterisk = hintsUsed>0 ? '*' : '';
        const tEff = effectiveTime();
        finalTime.textContent = `${fmtTime(tEff)}${usedAsterisk}${hintsUsed?` (base ${fmtTime(timer)}, +${hintsUsed*HINT_PENALTY_SEC}s)`:''}`;
        const key = keyForMix();
        const prevBest = +localStorage.getItem(key) || Infinity;
        if(tEff < prevBest){ localStorage.setItem(key, String(tEff)); }
        bestTime.textContent = isFinite(+localStorage.getItem(key)) ? `${fmtTime(+localStorage.getItem(key))}${(+localStorage.getItem(key)===tEff && hintsUsed>0?'*':'')}` : '‚Äî';
        finishModal.showModal();
        confetti({ particleCount: 200, spread: 70, origin:{ y:.6 } });
      }
      updateHintHUD(); updateHUD();
    }

    // ===== Hint (penalty + cooldown) =====
    let hintCooldownId = null; let hintCooldownLeft = 0;
    function enableHint(on){
      btnHint.disabled = !on; btnHint.textContent = on ? 'Hint' : `Hint (${hintCooldownLeft}s)`;
    }
    function tickHintCooldown(){
      hintCooldownLeft--; if(hintCooldownLeft<=0){ clearInterval(hintCooldownId); hintCooldownId=null; enableHint(true); }
      else { btnHint.textContent = `Hint (${hintCooldownLeft}s)`; }
    }
    function startHintCooldown(){
      hintCooldownLeft = HINT_COOLDOWN_SEC; enableHint(false);
      hintCooldownId = setInterval(tickHintCooldown, 1000);
    }

    function useHint(){
      if(btnHint.disabled) return; // safety
      const empties = [...tbody.querySelectorAll('.dropzone')].filter(td=>!td.textContent);
      if(empties.length===0){ showToast('No empty cells.'); return; }
      const td = empties[Math.floor(Math.random()*empties.length)];
      const r = +td.dataset.r, c = +td.dataset.c; const val = answers[r][c];
      const qi = queue.findIndex(x=> x.toLowerCase()===val.toLowerCase()); if(qi>=0){ queue.splice(qi,1); }
      td.textContent = val; td.style.background='rgba(59,91,219,.10)'; td.style.boxShadow='inset 0 0 0 2px rgba(59,91,219,.35)';
      hintsUsed++; showToast(`Hint used (+${HINT_PENALTY_SEC}s)`);
      startHintCooldown(); updateQueue(); updateHintHUD(); updateHUD();
    }

    // Restart keeps same mix
    function restart(){ buildBoard(); startGame(); }

    // Reset all returns to selection
    function resetAll(){ if(!confirm('Clear the board and return to selection?')) return; runTimer(false); gameCard.hidden = true; selCard.hidden = false; requestAnimationFrame(fitBoardToScreen); }

    // Drag with pointer
    let dragging = false; let offsetX=0, offsetY=0;
    tileEl.addEventListener('pointerdown', (e)=>{ dragging = true; tileEl.setPointerCapture(e.pointerId); tileEl.style.cursor='grabbing'; const rect = tileEl.getBoundingClientRect(); offsetX = e.clientX - rect.left; offsetY = e.clientY - rect.top; tileEl.style.position='fixed'; moveTile(e.clientX, e.clientY); });
    window.addEventListener('pointermove', (e)=>{ if(!dragging) return; moveTile(e.clientX, e.clientY); });
    window.addEventListener('pointerup', (e)=>{ if(!dragging) return; dragging=false; tileEl.releasePointerCapture?.(e.pointerId); tileEl.style.cursor='grab'; tileEl.style.position=''; tileEl.style.left=''; tileEl.style.top=''; tileEl.style.visibility='hidden'; const target = document.elementFromPoint(e.clientX, e.clientY); tileEl.style.visibility='visible'; const td = target?.closest?.('.dropzone'); if(td) placeInCell(td); });
    function moveTile(x,y){ tileEl.style.left = (x - offsetX) + 'px'; tileEl.style.top = (y - offsetY) + 'px'; }

    // ===== Mobile fit-to-screen (fit width, scroll height) =====
    const isMobile = matchMedia('(pointer:coarse)').matches || /Mobi|Android/i.test(navigator.userAgent);
    function fitBoardToScreen(){
      if(!isMobile){ boardScale.style.transform = ''; board.style.height = ''; board.style.overflow = 'auto'; return; }
      const natW = boardScale.scrollWidth; const natH = boardScale.scrollHeight; const rect = board.getBoundingClientRect();
      const availW = Math.max(320, window.innerWidth - 16); const scaleW = Math.min(availW / natW, 1); boardScale.style.transform = `scale(${scaleW})`;
      const availH = Math.max(240, window.innerHeight - rect.top - 12); board.style.height = Math.min(natH * scaleW, availH) + 'px'; board.style.overflow = 'auto'; }
    window.addEventListener('resize', ()=> requestAnimationFrame(fitBoardToScreen));

    // Buttons
    btnStart.addEventListener('click', ()=>{ if(selected.size===0){ showToast('Select at least one set'); return; } selCard.hidden = true; gameCard.hidden = false; buildBoard(); startGame(); localStorage.setItem('lastSelected', JSON.stringify([...selected])); });
    btnCheck.addEventListener('click', checkAnswers);
    btnRestart.addEventListener('click', ()=>{ restart(); requestAnimationFrame(fitBoardToScreen); });
    btnResetAll.addEventListener('click', resetAll);
    btnHint.addEventListener('click', useHint);

    openHelp.addEventListener('click', ()=> helpModal.showModal()); closeHelp.addEventListener('click', ()=> helpModal.close());
    playAgain.addEventListener('click', ()=>{ finishModal.close(); restart(); requestAnimationFrame(fitBoardToScreen); });
    closeFinish.addEventListener('click', ()=> finishModal.close());

    // Persist last selection
    const last = localStorage.getItem('lastSelected'); if(last){ try{ selected = new Set(JSON.parse(last)); }catch{} }
    renderPills();

    // ===== Minimal Self-tests (console) =====
    (function selfTests(){
      try{ console.group('%cSelf-tests','color:#3b5bdb;font-weight:bold');
        console.assert(Array.isArray(CORRECT) && CORRECT.length===10, '10 case rows');
        console.assert(CORRECT.every(r=>Array.isArray(r) && r.length===8), '8 decl columns');
        // Canonical order test
        const prevSel = new Set(selected); selected = new Set([3,0,5]); buildBoard();
        const headers = [...document.querySelectorAll('#thead-row th')].slice(1).map(th=>th.textContent.trim());
        console.assert(headers.join(',')==='1,3,4', 'Canonical order for subset'); selected = prevSel; buildBoard();
        // Theme toggle changes dataset
        const before = document.body.dataset.theme||'auto'; toggleTheme.click(); const after = document.body.dataset.theme||'auto'; console.assert(before!==after, 'Theme cycles');
        // Hint penalty arithmetic
        const base = timer; const beforeEff = effectiveTime(); hintsUsed++; const afterEff = effectiveTime(); console.assert(afterEff-beforeEff===HINT_PENALTY_SEC, 'Penalty +10s per hint'); hintsUsed--; timeEl.textContent = fmtTime(effectiveTime());
        console.groupEnd(); } catch(e){ console.error('Self-tests failed:', e); }
    })();

  })();
  </script>
</body>
</html>

