<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Latin Declension Drag & Drop Practice</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
  <style>
    :root {
      --royal-blue: #4169e1;
      --light-blue: #f5faff;
      --white: #ffffff;
      --gray-light: #f0f0f0;
      --red: #e74c3c;
      --green: #27ae60;
      --orange: #e67e22;
      --blue: #3498db;
      --pink: #fd79a8;
    }
    *, *::before, *::after { box-sizing: border-box; }
    body {
      font-family: 'Cinzel', serif;
      background: var(--light-blue);
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 { color: var(--royal-blue); text-align: center; margin-bottom: 10px; }

    /* ==== Selection Panel ==== */
    .panel {
      background: var(--white);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
      width: 90%;
      max-width: 400px;
      margin-bottom: 20px;
    }
    .panel h2 { margin-top: 0; text-align: center; }
    .panel label { display: block; margin: 8px 0; font-size: 1rem; }
    button {
      font-family: inherit;
      font-weight: 600;
      background: var(--royal-blue);
      color: var(--white);
      border: none;
      border-radius: 4px;
      padding: 10px 20px;
      cursor: pointer;
      transition: background .2s;
      margin: 5px;
    }
    button:hover { background: #27408B; }
    #timer { font-size: 1.2rem; margin-bottom: 10px; }
    #check-button, #restart-button { margin-bottom: 10px; }

    /* ==== Game Container ==== */
    #game-container {
      display: none;
      width: 100%;
      max-width: 800px;
      text-align: center;
      position: relative; /* Make this container the reference for absolute positioning */
    }

    /* ==== The draggable ending “ball” ==== */
    #current-ending {
      background: var(--white);
      border: 2px solid var(--royal-blue);
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      cursor: grab;
      user-select: none;
      transition: transform .2s;
      display: flex;
      align-items: center;
      justify-content: center;
      visibility: hidden;

      /* NEW: absolute positioning so we can move it under the finger */
      position: absolute;
      top: 0;    /* We’ll programmatically set “left/top” each time we show it */
      left: 50%; /* Center horizontally on start (will be updated) */
      transform: translateX(-50%); /* Centering shift */
      z-index: 10; /* Draw above table */
    }

    /* ==== Table styling ==== */
    .declension-table { width: 90%; max-width: 800px; margin-bottom: 20px; }
    table { width: 100%; border-collapse: collapse; table-layout: fixed; }
    th, td {
      border: 1px solid #aaa;
      text-align: center;
      padding: 8px;
      min-width: 60px;
      height: 50px;
      overflow: hidden;
    }
    .case-nominative th { background: var(--red); color: #fff; }
    .case-genitive th   { background: var(--green); color: #fff; }
    .case-dative th     { background: var(--orange); color: #000; }
    .case-accusative th { background: var(--blue); color: #fff; }
    .case-ablative th   { background: var(--pink); color: #000; }
    .dropzone.drag-over { background: var(--gray-light); }
  </style>
</head>
<body>
  <h1>Latin Declension Practice</h1>

  <!-- ==== Selection Panel ==== -->
  <div id="selection-container" class="panel">
    <h2>Select Declensions</h2>
    <form id="selection-form">
      <label><input type="checkbox" name="declension" value="0" checked> 1st Declension</label>
      <label><input type="checkbox" name="declension" value="1" checked> 2nd Declension</label>
      <label><input type="checkbox" name="declension" value="2"> 2nd Declension Neuter</label>
      <label><input type="checkbox" name="declension" value="3" checked> 3rd Declension</label>
      <label><input type="checkbox" name="declension" value="4"> 3rd Declension Neuter</label>
      <label><input type="checkbox" name="declension" value="5"> 4th Declension</label>
      <label><input type="checkbox" name="declension" value="6"> 4th Declension Neuter</label>
      <label><input type="checkbox" name="declension" value="7"> 5th Declension</label>
      <div style="text-align:center; margin-top:10px;">
        <button type="button" id="selection-start">Start Practice</button>
      </div>
    </form>
  </div>

  <!-- ==== Game Container ==== -->
  <div id="game-container">
    <div id="timer"></div>
    <button id="check-button">Check Answers</button>
    <button id="restart-button">Restart</button>

    <!-- This is the “draggable” ending bubble -->
    <div id="current-ending"></div>

    <!-- The table where students drop endings -->
    <div class="declension-table">
      <table>
        <thead>
          <tr id="table-header"><th>Case</th></tr>
        </thead>
        <tbody id="table-body"></tbody>
      </table>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      //—-------------------------------------------------------------------------
      // PART A: Data & Element References
      //—-------------------------------------------------------------------------
      const declensionLabels = ["1","2","2n","3","3n","4","4n","5"];
      const caseClasses = [
        'case-nominative','case-genitive','case-dative','case-accusative','case-ablative',
        'case-nominative','case-genitive','case-dative','case-accusative','case-ablative'
      ];
      const caseLabels = [
        'Nominative','Genitive','Dative','Accusative','Ablative',
        'Nominative-P','Genitive-P','Dative-P','Accusative-P','Ablative-P'
      ];

      // fullCorrect[r][c] = correct ending for row r, declension index c.
      const fullCorrect = [
        ["a","us/r","um","*","*","us","u","es"],
        ["ae","i","i","is","is","us","us","ei"],
        ["ae","o","o","i","i","ui","u","ei"],
        ["am","um","um","em","*","um","u","em"],
        ["a","o","o","e","e","u","u","e"],
        ["ae","i","a","es","a","us","ua","es"],
        ["arum","orum","orum","um","um","uum","uum","erum"],
        ["is","is","is","ibus","ibus","ibus","ibus","ebus"],
        ["as","os","a","es","a","us","ua","es"],
        ["is","is","is","ibus","ibus","ibus","ibus","ebus"]
      ];

      let selectedDecls = [];
      let correctAnswers = [];   // 2D array: correctAnswers[row][col]
      let initialPool = [];      // flat array of all endings for the chosen declensions
      let shuffled = [];         // pool we shuffle & consume
      let elapsed = 0;
      let timerInterval = null;
      let isDragging = false;
      let dragOffsetX = 0, dragOffsetY = 0;

      // Element references
      const selContainer  = document.getElementById('selection-container');
      const gameContainer = document.getElementById('game-container');
      const selStartBtn   = document.getElementById('selection-start');
      const timerEl       = document.getElementById('timer');
      const currentEl     = document.getElementById('current-ending');
      const tableHeader   = document.getElementById('table-header');
      const tableBody     = document.getElementById('table-body');
      const checkBtn      = document.getElementById('check-button');
      const restartBtn    = document.getElementById('restart-button');

      //—-------------------------------------------------------------------------
      // PART B: Initialization & Table Construction
      //—-------------------------------------------------------------------------
      selStartBtn.addEventListener('click', () => {
        selectedDecls = Array.from(document.querySelectorAll('input[name="declension"]:checked'))
                              .map(b => parseInt(b.value));
        if (!selectedDecls.length) {
          alert('Select at least one declension');
          return;
        }
        selContainer.style.display  = 'none';
        gameContainer.style.display = 'block';
        initialize();
      });

      restartBtn.addEventListener('click', () => {
        buildTable();
        startGame();
      });

      function initialize() {
        // Build a 2D array of correct answers only for chosen declensions
        correctAnswers = fullCorrect.map(row =>
          selectedDecls.map(colIndex => row[colIndex])
        );
        // Flatten into a single pool
        initialPool = correctAnswers.flat();
        buildTable();
        startGame();
      }

      function buildTable() {
        tableHeader.innerHTML = '<th>Case</th>';
        selectedDecls.forEach(ci => {
          const th = document.createElement('th');
          th.textContent = declensionLabels[ci];
          tableHeader.appendChild(th);
        });

        tableBody.innerHTML = '';
        correctAnswers.forEach((row, rowIndex) => {
          const tr = document.createElement('tr');
          tr.classList.add(caseClasses[rowIndex]);

          const th = document.createElement('th');
          th.textContent = caseLabels[rowIndex];
          tr.appendChild(th);

          row.forEach((_, colIndex) => {
            const td = document.createElement('td');
            td.classList.add('dropzone');
            td.dataset.row = rowIndex;
            td.dataset.col = colIndex;
            // We’ll handle pointer events instead of HTML5 DnD
            tr.appendChild(td);
          });
          tableBody.appendChild(tr);
        });
      }

      function shuffle(arr) {
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      }

      function startGame() {
        shuffled = shuffle(initialPool);
        clearInterval(timerInterval);
        elapsed = 0;
        updateTimer();
        timerInterval = setInterval(() => {
          elapsed++;
          updateTimer();
        }, 1000);
        showNext();
      }

      function updateTimer() {
        const m = Math.floor(elapsed / 60), s = elapsed % 60;
        timerEl.textContent = `Time: ${m}m ${s}s`;
      }

      function showNext() {
        if (!shuffled.length) {
          currentEl.style.visibility = 'hidden';
          return;
        }
        const nextVal = shuffled.shift();
        currentEl.textContent = nextVal;
        currentEl.style.visibility = 'visible';

        // After we set textContent, measure the visible cell size (optional)
        const someCell = document.querySelector('td.dropzone');
        if (someCell) {
          const rect = someCell.getBoundingClientRect();
          currentEl.style.width  = `${rect.width}px`;
          currentEl.style.height = `${rect.height}px`;
        }

        // Place it back in the middle (horizontally) at the top of game-container
        const gcRect = gameContainer.getBoundingClientRect();
        const elRect = currentEl.getBoundingClientRect();
        // Left: center within gameContainer
        currentEl.style.left = `${(gcRect.width / 2) - (elRect.width / 2)}px`;
        // Top: maybe 20px below the top of gameContainer
        currentEl.style.top  = `20px`;
      }

      //—-------------------------------------------------------------------------
      // PART C: Pointer/Touch Drag & Drop Logic
      //—-------------------------------------------------------------------------

      // When user touches (or clicks) the #current-ending bubble:
      currentEl.addEventListener('pointerdown', (evt) => {
        evt.preventDefault();
        isDragging = true;
        currentEl.style.cursor = 'grabbing';

        // Compute offset: where inside the bubble did you touch?
        const rect = currentEl.getBoundingClientRect();
        dragOffsetX = evt.clientX - rect.left;
        dragOffsetY = evt.clientY - rect.top;

        // Bring it to the front
        currentEl.style.zIndex = 999;
      });

      // As the user moves finger/mouse with pointer down:
      document.addEventListener('pointermove', (evt) => {
        if (!isDragging) return;
        evt.preventDefault();
        const parentRect = gameContainer.getBoundingClientRect();

        // Compute new left/top relative to gameContainer
        let newLeft = evt.clientX - parentRect.left - dragOffsetX;
        let newTop  = evt.clientY - parentRect.top  - dragOffsetY;

        // Optional: constrain within container bounds
        const bubbleRect = currentEl.getBoundingClientRect();
        const maxX = parentRect.width  - bubbleRect.width;
        const maxY = parentRect.height - bubbleRect.height;
        if (newLeft < 0) newLeft = 0;
        if (newLeft > maxX) newLeft = maxX;
        if (newTop < 0)  newTop = 0;
        if (newTop > maxY) newTop = maxY;

        currentEl.style.left = `${newLeft}px`;
        currentEl.style.top  = `${newTop}px`;
      });

      // On pointerup: we “drop” the bubble
      document.addEventListener('pointerup', (evt) => {
        if (!isDragging) return;
        isDragging = false;
        currentEl.style.cursor = 'grab';

        // Which element is directly under the finger now?
        const dropX = evt.clientX;
        const dropY = evt.clientY;
        currentEl.style.zIndex = 10; // Reset z-index

        // Hide the bubble temporarily so elementFromPoint isn’t “blocked” by it
        currentEl.style.visibility = 'hidden';
        const elemUnder = document.elementFromPoint(dropX, dropY);
        // Restore visibility immediately
        currentEl.style.visibility = 'visible';

        // If it’s a <td class="dropzone">, we place the text there:
        if (elemUnder && elemUnder.classList.contains('dropzone')) {
          const td = elemUnder;
          const r = parseInt(td.dataset.row, 10);
          const c = parseInt(td.dataset.col, 10);
          const attemptedVal = currentEl.textContent.trim();

          // If there was already something in that cell, put it back into the pool
          const oldText = td.textContent.trim();
          if (oldText) {
            shuffled.push(oldText);
          }
          td.textContent = attemptedVal;
          // Now we show the next bubble
          showNext();
        } else {
          // Not dropped on a dropzone → snap back to original position (in the center top)
          showNext();
        }
      });

      //—-------------------------------------------------------------------------
      // PART D: Checking Answers & Confetti
      //—-------------------------------------------------------------------------

      function checkAnswers() {
        const placed = [];
        document.querySelectorAll('td.dropzone').forEach(z => {
          const text = z.textContent.trim();
          if (!text) return;
          const r = parseInt(z.dataset.row, 10);
          const c = parseInt(z.dataset.col, 10);
          const corr = correctAnswers[r][c].toLowerCase();
          if (text.toLowerCase() === corr) {
            placed.push(text);
          } else {
            // Wrong answer → remove it immediately
            z.textContent = '';
          }
        });

        // Rebuild the pool from any correct ones (so they don’t reappear) vs. incorrect
        const remaining = initialPool.slice();
        placed.forEach(val => {
          const idx = remaining.findIndex(item => item.toLowerCase() === val.toLowerCase());
          if (idx >= 0) remaining.splice(idx, 1);
        });
        shuffled = shuffle(remaining);

        // If everything is correct/placed → celebrate
        if (remaining.length === 0) {
          clearInterval(timerInterval);
          confetti({
            particleCount: 100,
            spread: 70,
            origin: { y: 0.6 }
          });
        }
        showNext();
      }

      checkBtn.addEventListener('click', checkAnswers);

      //—-------------------------------------------------------------------------
      // END of Script
      //—-------------------------------------------------------------------------
    });
  </script>
</body>
</html>
